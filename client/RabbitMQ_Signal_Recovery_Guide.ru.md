
## –î–∞–Ω–Ω—ã–µ –∏–∑ RabbitMQ –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞

**–ò–∑ –∞–Ω–∞–ª–∏–∑–∞ –∫–æ–¥–∞ –∏ —Ä–µ–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö RabbitMQ, –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞ –∏ –¥–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Å–ª–µ–¥—É—é—â–∏–µ –¥–∞–Ω–Ω—ã–µ:**

### üì° **SIGNALS Queue (–¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞):**

**–û—Å–Ω–æ–≤–Ω—ã–µ –ø–æ–ª—è –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞:**
1. **`hex_string`** - `"AAB10209745E8C8155"` - **–ö–ª—é—á–µ–≤–æ–µ –ø–æ–ª–µ!** –°–æ–¥–µ—Ä–∂–∏—Ç –∫–æ–º–ø–∞–∫—Ç–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –≤—Å–µ—Ö timing –¥–∞–Ω–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ rfraw
2. **`pulses`** - `[2420, 24204]` - –ú–∞—Å—Å–∏–≤ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–µ–π –∏–º–ø—É–ª—å—Å–æ–≤ –∏ –ø–∞—É–∑ –≤ –º–∏–∫—Ä–æ—Å–µ–∫—É–Ω–¥–∞—Ö
3. **`mod`** - `"OOK"` –∏–ª–∏ `"FSK"` - –¢–∏–ø –º–æ–¥—É–ª—è—Ü–∏–∏
4. **`count`** - `1` - –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–º–ø—É–ª—å—Å–æ–≤

**–ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ RF –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è:**
- **`freq1_Hz`** - `433921472` - –û—Å–Ω–æ–≤–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞
- **`freq_Hz`** - `433920000` - –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞  
- **`rate_Hz`** - `250000` - –ß–∞—Å—Ç–æ—Ç–∞ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏
- **`depth_bits`** - `8` - –ì–ª—É–±–∏–Ω–∞ –≤ –±–∏—Ç–∞—Ö
- **`range_dB`** - `42.1442` - –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –¥–∏–∞–ø–∞–∑–æ–Ω
- **`rssi_dB`** - `2.41444` - –ú–æ—â–Ω–æ—Å—Ç—å —Å–∏–≥–Ω–∞–ª–∞
- **`snr_dB`** - –û—Ç–Ω–æ—à–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª/—à—É–º
- **`noise_dB`** - –£—Ä–æ–≤–µ–Ω—å —à—É–º–∞

**–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è:**
- **`offset`** - –°–º–µ—â–µ–Ω–∏–µ –≤ –ø–æ—Ç–æ–∫–µ –¥–∞–Ω–Ω—ã—Ö
- **`start_ago`** - –í—Ä–µ–º—è –Ω–∞—á–∞–ª–∞ —Å–∏–≥–Ω–∞–ª–∞ 
- **`end_ago`** - –í—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞
- **`ook_low_estimate`** / **`ook_high_estimate`** - –ü–æ—Ä–æ–≥–∏ –¥–ª—è OOK
- **`fsk_f1_est`** / **`fsk_f2_est_value`** - –ß–∞—Å—Ç–æ—Ç—ã –¥–ª—è FSK

### üìã **DETECTED Queue (–¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞):**

**–†–µ–∑—É–ª—å—Ç–∞—Ç –¥–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:**
- **`model`** - `"Toyota"` - –ú–æ–¥–µ–ª—å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
- **`type`** - `"TPMS"` - –¢–∏–ø —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞  
- **`id`** - `"d75c823b"` - –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
- **–°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ** - `pressure_PSI`, `temperature_C`, `status` –∏ —Ç.–¥.

### üîß **–ü—Ä–æ—Ü–µ—Å—Å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞:**

**1. –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ (—á–µ—Ä–µ–∑ hex_string):**
```c
// –§—É–Ω–∫—Ü–∏—è rtl433_signal_reconstruct_from_hex()
int rtl433_signal_reconstruct_from_hex(const char *hex_str, 
                                      pulse_data_t *pulse_data,
                                      const char *json_metadata)
```

**2. –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –º–µ—Ç–æ–¥ (—á–µ—Ä–µ–∑ pulses array):**
```json
{
  "pulses": [2420, 24204],  // –ú–∞—Å—Å–∏–≤ –∏–º–ø—É–ª—å—Å-–ø–∞—É–∑–∞-–∏–º–ø—É–ª—å—Å...
  "rate_Hz": 250000,        // –ß–∞—Å—Ç–æ—Ç–∞ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏ –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ timing
  "mod": "OOK"             // –¢–∏–ø –º–æ–¥—É–ª—è—Ü–∏–∏
}
```

### üéØ **–ö–ª—é—á–µ–≤—ã–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:**

1. **`hex_string`** - —Å–∞–º—ã–π –∫–æ–º–ø–∞–∫—Ç–Ω—ã–π –∏ —Ç–æ—á–Ω—ã–π —Å–ø–æ—Å–æ–± –ø–µ—Ä–µ–¥–∞—á–∏ timing –¥–∞–Ω–Ω—ã—Ö
2. **`pulses` array** - —Ä–µ–∑–µ—Ä–≤–Ω—ã–π –º–µ—Ç–æ–¥, –µ—Å–ª–∏ hex_string –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
3. **RF –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ** (—á–∞—Å—Ç–æ—Ç—ã, RSSI, SNR) –∫—Ä–∏—Ç–∏—á–Ω—ã –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
4. **Time correlation** –º–µ–∂–¥—É 'signals' –∏ 'detected' —á–µ—Ä–µ–∑ –ø–æ–ª–µ `time`

**–ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –¥–ª—è –¥–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:**
```c
// 1. –ü–æ–ª—É—á–∏—Ç—å JSON –∏–∑ RabbitMQ 'signals'
// 2. –ò–∑–≤–ª–µ—á—å hex_string: "AAB10209745E8C8155"  
// 3. –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å pulse_data_t —Å—Ç—Ä—É–∫—Ç—É—Ä—É
// 4. –ü—Ä–∏–º–µ–Ω–∏—Ç—å –¥–µ—Ç–µ–∫—Ç–æ—Ä—ã —É—Å—Ç—Ä–æ–π—Å—Ç–≤
// 5. –†–µ–∑—É–ª—å—Ç–∞—Ç –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤ 'detected' –æ—á–µ—Ä–µ–¥—å
```

–¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, **hex_string** —è–≤–ª—è–µ—Ç—Å—è –æ—Å–Ω–æ–≤–Ω—ã–º –ø–æ–ª–µ–º –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞, –∞ **pulses array + –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ** - —Ä–µ–∑–µ—Ä–≤–Ω—ã–º –º–µ—Ç–æ–¥–æ–º –¥–ª—è –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.

```c
// –§—É–Ω–∫—Ü–∏—è rtl433_signal_reconstruct_from_hex()
int rtl433_signal_reconstruct_from_hex(const char *hex_str, 
                                      pulse_data_t *pulse_data,
                                      const char *json_metadata)
```

```json
{
  "pulses": [2420, 24204],  // –ú–∞—Å—Å–∏–≤ –∏–º–ø—É–ª—å—Å-–ø–∞—É–∑–∞-–∏–º–ø—É–ª—å—Å...
  "rate_Hz": 250000,        // –ß–∞—Å—Ç–æ—Ç–∞ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏ –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ timing
  "mod": "OOK"             // –¢–∏–ø –º–æ–¥—É–ª—è—Ü–∏–∏
}
```

```c
// 1. –ü–æ–ª—É—á–∏—Ç—å JSON –∏–∑ RabbitMQ 'signals'
// 2. –ò–∑–≤–ª–µ—á—å hex_string: "AAB10209745E8C8155"  
// 3. –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å pulse_data_t —Å—Ç—Ä—É–∫—Ç—É—Ä—É
// 4. –ü—Ä–∏–º–µ–Ω–∏—Ç—å –¥–µ—Ç–µ–∫—Ç–æ—Ä—ã —É—Å—Ç—Ä–æ–π—Å—Ç–≤
// 5. –†–µ–∑—É–ª—å—Ç–∞—Ç –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤ 'detected' –æ—á–µ—Ä–µ–¥—å
```

---

**User**

–∫–∞–∫–∏–µ –¥–∞–Ω–Ω—ã–µ –Ω—É–∂–Ω—ã –µ—Å–ª–∏ –µ—Å—Ç—å —Ç–æ–ª—å–∫–æ hex_string

---

**Cursor**

–û—Ç–ª–∏—á–Ω—ã–π –≤–æ–ø—Ä–æ—Å! –î–∞–≤–∞–π—Ç–µ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º, –∫–∞–∫–∏–µ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –Ω—É–∂–Ω—ã –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞, –µ—Å–ª–∏ —É –Ω–∞—Å –µ—Å—Ç—å —Ç–æ–ª—å–∫–æ `hex_string`.

–¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ —Ñ—É–Ω–∫—Ü–∏–∏ `rtl433_signal_set_defaults` –∏ –ø–∞—Ä—Å–∏–Ω–≥ hex_string:

–¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ —Ñ—É–Ω–∫—Ü–∏—é –ø–∞—Ä—Å–∏–Ω–≥–∞ hex_string –∏ —á—Ç–æ –æ–Ω–∞ –∏–∑–≤–ª–µ–∫–∞–µ—Ç:

–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å —É –º–µ–Ω—è –µ—Å—Ç—å –ø–æ–ª–Ω–∞—è –∫–∞—Ä—Ç–∏–Ω–∞. –î–∞–≤–∞–π—Ç–µ —Å–æ–∑–¥–∞–¥–∏–º –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –ø—Ä–∏–º–µ—Ä –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏:

```python
#!/usr/bin/env python3
"""
–ê–Ω–∞–ª–∏–∑ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞ –∏–∑ hex_string
"""
import json

# –ü—Ä–∏–º–µ—Ä —Ä–µ–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –∏–∑ RabbitMQ signals queue
signal_data = {
    "time": "@0.524288s",
    "mod": "OOK",
    "count": 1,
    "pulses": [2420, 24204],
    "freq1_Hz": 433921472,
    "freq_Hz": 433920000,
    "rate_Hz": 250000,
    "depth_bits": 8,
    "range_dB": 42.1442,
    "rssi_dB": 2.41444,
    "snr_dB": 0.63729,
    "noise_dB": -0.637554,
    "offset": 1025,
    "start_ago": 130047,
    "end_ago": 123391,
    "ook_low_estimate": 14147,
    "ook_high_estimate": 28567,
    "fsk_f1_est": 388,
    "fsk_f2_est_value": 0,
    "hex_string": "AAB10209745E8C8155"
}

print("=== –ê–ù–ê–õ–ò–ó: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –∏–∑ hex_string ===\n")

print("1. üéØ –ï–î–ò–ù–°–¢–í–ï–ù–ù–û–ï –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û–ï –ü–û–õ–ï:")
print(f"   hex_string: '{signal_data['hex_string']}'")
print("   ‚Ü≥ –°–æ–¥–µ—Ä–∂–∏—Ç –í–°–ï timing –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞\n")

print("2. üìä –ü–û–õ–Ø, –ò–ú–ï–Æ–©–ò–ï –î–ï–§–û–õ–¢–ù–´–ï –ó–ù–ê–ß–ï–ù–ò–Ø (–µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω—ã):")
defaults = {
    "sample_rate": "250000 Hz (–∏–∑ rtl433_signal_set_defaults)",
    "depth_bits": "8 bits",
    "centerfreq_hz": "433920000 Hz (–∏–∑ rtl433_rfraw_parse_hex_string)",
    "freq1_hz": "= centerfreq_hz",
    "offset": "0",
    "start_ago": "0", 
    "end_ago": "0",
    "ook_low_estimate": "1000",
    "ook_high_estimate": "8000",
    "fsk_f1_est": "0",
    "fsk_f2_est": "0",
    "range_db": "0.0",
    "rssi_db": "0.0",
    "snr_db": "0.0",
    "noise_db": "0.0"
}

for field, default in defaults.items():
    print(f"   {field}: {default}")

print("\n3. üîß –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –ú–ï–¢–ê–î–ê–ù–ù–´–ï (—É–ª—É—á—à–∞—é—Ç –∫–∞—á–µ—Å—Ç–≤–æ):")
important_metadata = {
    "freq_Hz": "–¢–æ—á–Ω–∞—è —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞",
    "rate_Hz": "–†–µ–∞–ª—å–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏", 
    "rssi_dB": "–ú–æ—â–Ω–æ—Å—Ç—å —Å–∏–≥–Ω–∞–ª–∞",
    "snr_dB": "–û—Ç–Ω–æ—à–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª/—à—É–º",
    "noise_dB": "–£—Ä–æ–≤–µ–Ω—å —à—É–º–∞"
}

for field, description in important_metadata.items():
    if field in signal_data:
        print(f"   {field}: {signal_data[field]} - {description}")

print("\n4. üìã –ú–ò–ù–ò–ú–ê–õ–¨–ù–´–ô JSON –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è:")
minimal_json = {
    "hex_string": signal_data["hex_string"]
}
print(json.dumps(minimal_json, indent=2))

print("\n5. üöÄ –†–ï–ö–û–ú–ï–ù–î–£–ï–ú–´–ô JSON –¥–ª—è –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è:")
recommended_json = {
    "hex_string": signal_data["hex_string"],
    "freq_Hz": signal_data["freq_Hz"], 
    "rate_Hz": signal_data["rate_Hz"],
    "rssi_dB": signal_data["rssi_dB"],
    "snr_dB": signal_data["snr_dB"],
    "noise_dB": signal_data["noise_dB"]
}
print(json.dumps(recommended_json, indent=2))

print("\n6. üîç –ß–¢–û –°–û–î–ï–†–ñ–ò–¢ hex_string:")
hex_analysis = {
    "AA": "Header (0xAA = OOK format)",
    "B1": "Modulation info",
    "02": "Payload length",
    "09": "Timing histogram count (9 bins)",
    "745E8C8155": "Timing data + pulse/gap pairs"
}

hex_string = signal_data["hex_string"]
print(f"   hex_string: {hex_string}")
for i, (part, description) in enumerate(hex_analysis.items()):
    if i < 4:  # First 4 parts are fixed length
        start_pos = i * 2
        hex_part = hex_string[start_pos:start_pos+2] if start_pos < len(hex_string) else "??"
        print(f"   {hex_part}: {description}")
    else:
        remaining = hex_string[8:]
        print(f"   {remaining}: {description}")

print("\nüí° –í–´–í–û–î:")
print("   ‚Ä¢ hex_string - –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û–ï –ø–æ–ª–µ")
print("   ‚Ä¢ freq_Hz, rate_Hz, rssi_dB - –†–ï–ö–û–ú–ï–ù–î–£–ï–ú–´–ï –¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏")
print("   ‚Ä¢ –í—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø–æ–ª—è –∏–º–µ—é—Ç —Ä–∞–∑—É–º–Ω—ã–µ –¥–µ—Ñ–æ–ª—Ç—ã")
```

## –û—Ç–≤–µ—Ç: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞ –∏–∑ hex_string

### üéØ **–ï–î–ò–ù–°–¢–í–ï–ù–ù–û–ï –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û–ï –ü–û–õ–ï:**

```json
{
  "hex_string": "AAB10209745E8C8155"
}
```

**hex_string —Å–æ–¥–µ—Ä–∂–∏—Ç –í–°–ï timing –¥–∞–Ω–Ω—ã–µ** –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –∏–º–ø—É–ª—å—Å–æ–≤ –∏ –ø–∞—É–∑ —Å–∏–≥–Ω–∞–ª–∞.

### üìä **–ü–æ–ª—è —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º–∏ –¥–µ—Ñ–æ–ª—Ç–∞–º–∏:**

–ï—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω—ã, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é—Ç—Å—è —Å–ª–µ–¥—É—é—â–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è:

| –ü–æ–ª–µ | –î–µ—Ñ–æ–ª—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ | –ò—Å—Ç–æ—á–Ω–∏–∫ |
|------|-------------------|----------|
| `sample_rate` | `250000 Hz` | `rtl433_signal_set_defaults()` |
| `centerfreq_hz` | `433920000 Hz` | `rtl433_rfraw_parse_hex_string()` |
| `freq1_hz` | `= centerfreq_hz` | –∫–æ–ø–∏—Ä—É–µ—Ç—Å—è |
| `depth_bits` | `8` | —Å—Ç–∞–Ω–¥–∞—Ä—Ç |
| `offset` | `0` | –Ω–∞—á–∞–ª–æ –ø–æ—Ç–æ–∫–∞ |
| `rssi_db`, `snr_db`, `noise_db` | `0.0` | –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ |
| `ook_low_estimate` | `1000` | –ø–æ—Ä–æ–≥ –¥–µ—Ç–µ–∫—Ü–∏–∏ |
| `ook_high_estimate` | `8000` | –ø–æ—Ä–æ–≥ –¥–µ—Ç–µ–∫—Ü–∏–∏ |

### üîß **–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ (–¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏):**

```json
{
  "hex_string": "AAB10209745E8C8155",
  "freq_Hz": 433920000,      // –¢–æ—á–Ω–∞—è —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞
  "rate_Hz": 250000,         // –†–µ–∞–ª—å–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏  
  "rssi_dB": 2.41444,        // –ú–æ—â–Ω–æ—Å—Ç—å —Å–∏–≥–Ω–∞–ª–∞
  "snr_dB": 0.63729,         // –û—Ç–Ω–æ—à–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª/—à—É–º
  "noise_dB": -0.637554      // –£—Ä–æ–≤–µ–Ω—å —à—É–º–∞
}
```

### üîç **–°—Ç—Ä—É–∫—Ç—É—Ä–∞ hex_string:**

```
AAB10209745E8C8155
‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Timing data + pulse/gap pairs  
‚îÇ‚îÇ‚îÇ‚îî‚îÄ 09: Timing histogram count (9 bins)
‚îÇ‚îÇ‚îî‚îÄ‚îÄ 02: Payload length
‚îÇ‚îî‚îÄ‚îÄ‚îÄ B1: Modulation info
‚îî‚îÄ‚îÄ‚îÄ‚îÄ AA: Header (0xAA = OOK format)
```

### üí° **–ü—Ä–æ—Ü–µ—Å—Å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è:**

```c
// –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∫–æ–¥ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è:
pulse_data_t pulse_data;
int result = rtl433_signal_reconstruct_from_hex("AAB10209745E8C8155", 
                                                &pulse_data, 
                                                NULL);  // –±–µ–∑ JSON –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö

// –° –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ –¥–ª—è –ª—É—á—à–µ–≥–æ –∫–∞—á–µ—Å—Ç–≤–∞:
char *json_metadata = "{\"freq_Hz\":433920000,\"rate_Hz\":250000,\"rssi_dB\":2.41}";
int result = rtl433_signal_reconstruct_from_hex("AAB10209745E8C8155", 
                                                &pulse_data, 
                                                json_metadata);
```

### üéØ **–ö–ª—é—á–µ–≤—ã–µ –≤—ã–≤–æ–¥—ã:**

1. **`hex_string`** - –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ **–û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û–ï** –ø–æ–ª–µ
2. **RF –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ** (`freq_Hz`, `rate_Hz`, `rssi_dB`) - **–†–ï–ö–û–ú–ï–ù–î–£–ï–ú–´–ï** –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –¥–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
3. **–í—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø–æ–ª—è** –∏–º–µ—é—Ç **—Ä–∞–∑—É–º–Ω—ã–µ –¥–µ—Ñ–æ–ª—Ç—ã**
4. **hex_string** —Å–æ–¥–µ—Ä–∂–∏—Ç **–ø–æ–ª–Ω—É—é timing –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é** –≤ –∫–æ–º–ø–∞–∫—Ç–Ω–æ–º –≤–∏–¥–µ
5. **–î–µ—Ñ–æ–ª—Ç—ã –¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã** –¥–ª—è –±–∞–∑–æ–≤–æ–≥–æ –¥–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è, –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —É–ª—É—á—à–∞—é—Ç —Ç–æ—á–Ω–æ—Å—Ç—å

**–¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–æ–ª—å–∫–æ `hex_string`, –Ω–æ –¥–ª—è –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –¥–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –¥–æ–±–∞–≤–∏—Ç—å RF –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ.**

```json
{
  "hex_string": "AAB10209745E8C8155"
}
```

```json
{
  "hex_string": "AAB10209745E8C8155",
  "freq_Hz": 433920000,      // –¢–æ—á–Ω–∞—è —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞
  "rate_Hz": 250000,         // –†–µ–∞–ª—å–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏  
  "rssi_dB": 2.41444,        // –ú–æ—â–Ω–æ—Å—Ç—å —Å–∏–≥–Ω–∞–ª–∞
  "snr_dB": 0.63729,         // –û—Ç–Ω–æ—à–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª/—à—É–º
  "noise_dB": -0.637554      // –£—Ä–æ–≤–µ–Ω—å —à—É–º–∞
}
```

```plaintext
AAB10209745E8C8155
‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Timing data + pulse/gap pairs  
‚îÇ‚îÇ‚îÇ‚îî‚îÄ 09: Timing histogram count (9 bins)
‚îÇ‚îÇ‚îî‚îÄ‚îÄ 02: Payload length
‚îÇ‚îî‚îÄ‚îÄ‚îÄ B1: Modulation info
‚îî‚îÄ‚îÄ‚îÄ‚îÄ AA: Header (0xAA = OOK format)
```

```c
// –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∫–æ–¥ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è:
pulse_data_t pulse_data;
int result = rtl433_signal_reconstruct_from_hex("AAB10209745E8C8155", 
                                                &pulse_data, 
                                                NULL);  // –±–µ–∑ JSON –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö

// –° –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ –¥–ª—è –ª—É—á—à–µ–≥–æ –∫–∞—á–µ—Å—Ç–≤–∞:
char *json_metadata = "{\"freq_Hz\":433920000,\"rate_Hz\":250000,\"rssi_dB\":2.41}";
int result = rtl433_signal_reconstruct_from_hex("AAB10209745E8C8155", 
                                                &pulse_data, 
                                                json_metadata);
```

---

**User**

Create document explained yours answer about "Data from RabbitMQ for signal recovery"

---

**Cursor**

I'll create a comprehensive document explaining the data from RabbitMQ for signal recovery based on our analysis.

```markdown
# RabbitMQ Signal Recovery Guide

## Overview

This document explains how to use data from RabbitMQ queues to reconstruct and detect RF signals in the rtl_433 system. The system uses two main queues: 'signals' for raw signal data and 'detected' for decoded device information.

## Queue Structure

### üì° SIGNALS Queue (Raw Signal Data)

The 'signals' queue contains raw pulse data that can be used to reconstruct the original RF signal for detection purposes.

#### Complete Signal Data Structure

```json
{
  "time": "@0.524288s",
  "mod": "OOK",
  "count": 1,
  "pulses": [2420, 24204],
  "freq1_Hz": 433921472,
  "freq_Hz": 433920000,
  "rate_Hz": 250000,
  "depth_bits": 8,
  "range_dB": 42.1442,
  "rssi_dB": 2.41444,
  "snr_dB": 0.63729,
  "noise_dB": -0.637554,
  "offset": 1025,
  "start_ago": 130047,
  "end_ago": 123391,
  "ook_low_estimate": 14147,
  "ook_high_estimate": 28567,
  "fsk_f1_est": 388,
  "fsk_f2_est_value": 0,
  "hex_string": "AAB10209745E8C8155"
}
```

### üìã DETECTED Queue (Decoded Device Data)

The 'detected' queue contains the results of successful device detection and decoding.

```json
{
  "time": "@133.026779s",
  "model": "Toyota", 
  "type": "TPMS",
  "id": "d75c823b",
  "status": 130,
  "pressure_PSI": 29.0,
  "temperature_C": 29.0,
  "mic": "CRC"
}
```

## Signal Reconstruction Methods

### Method 1: Using hex_string (Recommended)

The `hex_string` field contains the most compact and accurate representation of timing data.

#### Minimum Required Data

```json
{
  "hex_string": "AAB10209745E8C8155"
}
```

**This single field contains ALL timing information needed for signal reconstruction.**

#### hex_string Structure

```
AAB10209745E8C8155
‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Timing data + pulse/gap pairs  
‚îÇ‚îÇ‚îÇ‚îî‚îÄ 09: Timing histogram count (9 bins)
‚îÇ‚îÇ‚îî‚îÄ‚îÄ 02: Payload length
‚îÇ‚îî‚îÄ‚îÄ‚îÄ B1: Modulation info
‚îî‚îÄ‚îÄ‚îÄ‚îÄ AA: Header (0xAA = OOK format)
```

#### Reconstruction Process

```c
// Basic reconstruction (minimum data)
pulse_data_t pulse_data;
int result = rtl433_signal_reconstruct_from_hex("AAB10209745E8C8155", 
                                                &pulse_data, 
                                                NULL);

// Enhanced reconstruction with metadata
char *json_metadata = "{\"freq_Hz\":433920000,\"rate_Hz\":250000,\"rssi_dB\":2.41}";
int result = rtl433_signal_reconstruct_from_hex("AAB10209745E8C8155", 
                                                &pulse_data, 
                                                json_metadata);
```

#### Default Values (Applied Automatically)

| Field | Default Value | Source |
|-------|---------------|--------|
| `sample_rate` | 250000 Hz | `rtl433_signal_set_defaults()` |
| `centerfreq_hz` | 433920000 Hz | `rtl433_rfraw_parse_hex_string()` |
| `freq1_hz` | = centerfreq_hz | Copied from center frequency |
| `depth_bits` | 8 | Standard bit depth |
| `offset` | 0 | Stream start |
| `rssi_db`, `snr_db`, `noise_db` | 0.0 | Unknown values |
| `ook_low_estimate` | 1000 | Detection threshold |
| `ook_high_estimate` | 8000 | Detection threshold |

### Method 2: Using pulses Array (Fallback)

For signals that cannot generate a hex_string (complex signals with >8 timing bins):

#### Required Fields

```json
{
  "pulses": [2420, 24204],
  "mod": "OOK", 
  "rate_Hz": 250000,
  "count": 1
}
```

#### Field Descriptions

- **`pulses`**: Array of pulse and gap durations in microseconds [pulse1, gap1, pulse2, gap2, ...]
- **`mod`**: Modulation type ("OOK" or "FSK")
- **`rate_Hz`**: Sample rate for accurate timing conversion
- **`count`**: Number of pulses in the signal

## Enhanced Reconstruction (Recommended)

### Essential Metadata Fields

For high-quality signal reconstruction, include these additional fields:

```json
{
  "hex_string": "AAB10209745E8C8155",
  "freq_Hz": 433920000,      // Exact center frequency
  "rate_Hz": 250000,         // Actual sample rate
  "rssi_dB": 2.41444,        // Signal strength
  "snr_dB": 0.63729,         // Signal-to-noise ratio
  "noise_dB": -0.637554      // Noise level
}
```

### RF Quality Parameters

- **`freq_Hz`**: Critical for proper demodulation and device matching
- **`rssi_dB`**: Helps with signal quality assessment
- **`snr_dB`**: Important for weak signal detection
- **`noise_dB`**: Baseline noise level for threshold calculations

## Signal Processing Pipeline

### 1. Data Extraction from RabbitMQ

```python
# Example: Extract signal data from RabbitMQ
import pika
import json

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

method_frame, header_frame, body = channel.basic_get('signals')
if method_frame:
    signal_data = json.loads(body.decode())
    hex_string = signal_data.get('hex_string')
    metadata = {
        'freq_Hz': signal_data.get('freq_Hz'),
        'rate_Hz': signal_data.get('rate_Hz'), 
        'rssi_dB': signal_data.get('rssi_dB')
    }
```

### 2. Signal Reconstruction

```c
// C code for signal reconstruction
pulse_data_t pulse_data;
memset(&pulse_data, 0, sizeof(pulse_data_t));

// Method 1: Using hex_string (preferred)
if (hex_string) {
    char *json_meta = create_json_from_metadata(metadata);
    result = rtl433_signal_reconstruct_from_hex(hex_string, &pulse_data, json_meta);
    free(json_meta);
}

// Method 2: Using pulse array (fallback)
else if (pulses_array) {
    result = rtl433_signal_reconstruct_from_pulses(&pulse_data, pulses_array, 
                                                   pulse_count, sample_rate);
}
```

### 3. Device Detection

```c
// Apply device detectors to reconstructed signal
r_device **devices = get_all_devices();
for (int i = 0; devices[i]; i++) {
    r_device *device = devices[i];
    if (device->decode_fn) {
        int detection_result = device->decode_fn(&pulse_data, device);
        if (detection_result > 0) {
            // Device detected - send to 'detected' queue
            send_to_detected_queue(device_data);
        }
    }
}
```

## Time-Based Correlation

### Matching Signals to Detected Devices

Both 'signals' and 'detected' queues include a `time` field for correlation:

```json
// Signal in 'signals' queue
{
  "time": "@0.524288s",
  "hex_string": "AAB10209745E8C8155",
  ...
}

// Corresponding detection in 'detected' queue  
{
  "time": "@0.524288s",
  "model": "Toyota",
  "id": "d75c823b",
  ...
}
```

### Correlation Logic

```python
def correlate_signal_to_detection(signal_time, detected_time, tolerance_ms=100):
    """
    Correlate signal and detection based on timestamps
    """
    # Parse time format "@123.456s" 
    sig_time = float(signal_time.strip('@s'))
    det_time = float(detected_time.strip('@s'))
    
    # Check if within tolerance
    return abs(sig_time - det_time) <= (tolerance_ms / 1000.0)
```

## Performance Considerations

### Data Size Optimization

- **hex_string**: Most compact format (~20 bytes typical)
- **pulses array**: Larger but more detailed (~100+ bytes)
- **Full metadata**: Complete but verbose (~500+ bytes)

### Reconstruction Speed

1. **hex_string method**: Fastest reconstruction
2. **pulses array method**: Moderate speed 
3. **Complex signals**: May require full bitbuffer data

### Memory Usage

- **hex_string**: Minimal memory footprint
- **pulse arrays**: Linear with pulse count
- **Full signal data**: Higher memory usage

## Error Handling

### Common Issues

1. **Invalid hex_string format**: Check header bytes (0xAA family)
2. **Too many timing bins**: >8 bins cannot use hex_string format
3. **Missing metadata**: Use defaults but quality may suffer
4. **Corrupted timing data**: Validate pulse durations

### Validation

```c
// Validate reconstructed signal
bool is_valid = rtl433_signal_validate_pulse_data(&pulse_data);
if (!is_valid) {
    // Handle invalid signal data
    return -1;
}

// Check reasonable pulse durations (1Œºs to 100ms)
for (int i = 0; i < pulse_data.num_pulses; i++) {
    float pulse_us = pulse_data.pulse[i] * 1e6 / pulse_data.sample_rate;
    if (pulse_us < 1.0 || pulse_us > 100000.0) {
        // Invalid pulse duration
        return -1;
    }
}
```

## Best Practices

### 1. Data Prioritization

1. **Always prefer hex_string** when available
2. **Include RF metadata** for quality reconstruction  
3. **Use pulse arrays as fallback** for complex signals
4. **Validate reconstructed data** before processing

### 2. Queue Management

1. **Process signals queue immediately** to prevent overflow
2. **Correlate with detected queue** for feedback
3. **Handle missing data gracefully** with defaults
4. **Monitor queue sizes** and processing rates

### 3. Signal Quality

1. **Check RSSI values** for signal strength
2. **Validate SNR ratios** for detection confidence
3. **Use frequency data** for proper demodulation
4. **Apply appropriate thresholds** based on noise levels

## Code Examples

### Complete Signal Recovery Example

```c
#include "rtl433_signal.h"
#include "rtl433_transport.h"

int process_rabbitmq_signal(const char *json_message) {
    // Parse JSON from RabbitMQ
    json_object *root = json_tokener_parse(json_message);
    if (!root) return -1;
    
    // Extract hex_string
    json_object *hex_obj;
    if (!json_object_object_get_ex(root, "hex_string", &hex_obj)) {
        json_object_put(root);
        return -1;
    }
    
    const char *hex_string = json_object_get_string(hex_obj);
    
    // Extract metadata
    char metadata_json[512];
    snprintf(metadata_json, sizeof(metadata_json),
        "{\"freq_Hz\":%d,\"rate_Hz\":%d,\"rssi_dB\":%.2f}",
        get_json_int(root, "freq_Hz", 433920000),
        get_json_int(root, "rate_Hz", 250000), 
        get_json_double(root, "rssi_dB", 0.0));
    
    // Reconstruct signal
    pulse_data_t pulse_data;
    int result = rtl433_signal_reconstruct_from_hex(hex_string, 
                                                   &pulse_data, 
                                                   metadata_json);
    
    json_object_put(root);
    
    if (result != 0) {
        return -1; // Reconstruction failed
    }
    
    // Validate reconstructed signal
    if (!rtl433_signal_validate_pulse_data(&pulse_data)) {
        return -1; // Invalid signal data
    }
    
    // Process with device detectors
    return run_device_detectors(&pulse_data);
}
```

## Summary

The RabbitMQ signal recovery system provides flexible options for signal reconstruction:

- **üéØ Minimum**: Only `hex_string` required
- **üîß Recommended**: `hex_string` + RF metadata (`freq_Hz`, `rate_Hz`, `rssi_dB`)
- **üìä Fallback**: `pulses` array for complex signals
- **‚è±Ô∏è Correlation**: Time-based matching between signals and detections

This architecture enables efficient signal processing while maintaining compatibility with various signal types and quality levels.
```

I've created a comprehensive document `RabbitMQ_Signal_Recovery_Guide.md` that explains everything about using RabbitMQ data for signal recovery. The document covers:

## üìã **Document Sections:**

1. **Overview** - Introduction to the RabbitMQ queue system
2. **Queue Structure** - Detailed breakdown of 'signals' and 'detected' queues
3. **Signal Reconstruction Methods** - Two main approaches (hex_string and pulses array)
4. **Enhanced Reconstruction** - Recommended metadata for quality improvement
5. **Signal Processing Pipeline** - Complete workflow from RabbitMQ to detection
6. **Time-Based Correlation** - How to match signals with detections
7. **Performance Considerations** - Optimization strategies
8. **Error Handling** - Common issues and validation
9. **Best Practices** - Guidelines for production use
10. **Code Examples** - Complete working implementations

## üéØ **Key Highlights:**

- **Minimum data**: Only `hex_string` required for basic reconstruction
- **Recommended data**: `hex_string` + RF metadata for quality reconstruction  
- **Fallback method**: `pulses` array for complex signals
- **Time correlation**: Matching signals to detected devices
- **Complete code examples** in both C and Python

The document serves as a comprehensive reference for anyone working with RabbitMQ signal recovery in the rtl_433 system, from basic usage to advanced optimization techniques.

